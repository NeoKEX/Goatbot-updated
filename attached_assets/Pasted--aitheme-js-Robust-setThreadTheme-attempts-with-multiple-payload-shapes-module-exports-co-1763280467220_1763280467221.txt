// aitheme.js
// Robust setThreadTheme attempts with multiple payload shapes
module.exports = {
  config: {
    name: "aitheme",
    version: "5.1.1",
    author: "mahi--",
    access: 2,
    countdown: 5,
    description: {
      en:
        "Create AI themes or directly apply a theme by ID. Supports variants, image URL input, and a direct --id mode to set themes without generating."
    },
    category: "owner",
    guide: {
      en:
        "{pn} <prompt> [--v <1-5>] [--url <image_url>]  OR  {pn} --id <theme_id> [--target <thread_id>]"
    }
  },

  onStart: async function ({ args, message, api, event }) {
    try {
      // --- Parse args ---
      let collectedPrompt = [];
      let variantCount = 1;
      let bgUrl = null;
      let directId = null;
      let targetThread = null;

      for (let i = 0; i < args.length; i++) {
        const token = args[i];
        if ((token === "--v" || token === "-v") && args[i + 1]) {
          variantCount = parseInt(args[i + 1], 10) || 1;
          i++;
        } else if ((token === "--url" || token === "-u") && args[i + 1]) {
          bgUrl = args[i + 1];
          i++;
        } else if ((token === "--id" || token === "-i") && args[i + 1]) {
          directId = args[i + 1];
          i++;
        } else if ((token === "--target" || token === "--tid") && args[i + 1]) {
          targetThread = args[i + 1];
          i++;
        } else {
          collectedPrompt.push(token);
        }
      }

      const promptText = collectedPrompt.join(" ").trim();
      variantCount = Math.min(5, Math.max(1, variantCount)); // clamp 1..5

      // helper: resolve thread id (string or numeric)
      const resolveThreadId = (candidate) => {
        if (!candidate) return null;
        // sometimes thread IDs come as objects; if so, try to extract id property
        if (typeof candidate === "object") {
          return candidate.threadID || candidate.threadId || candidate.id || null;
        }
        return String(candidate);
      };

      // --- Theme apply helper: tries multiple payload shapes ---
      const tryApplyTheme = async (threadId, themeIdentifier, selectedObject = null) => {
        if (typeof api.setThreadTheme !== "function") {
          throw new Error("setThreadTheme API is not available in this environment.");
        }

        const candidates = [
          // plain id
          () => api.setThreadTheme(threadId, themeIdentifier, (e, d) => (e ? Promise.reject(e) : Promise.resolve(d))),
          // various common shapes
          () =>
            api.setThreadTheme(threadId, { themeId: themeIdentifier }, (e, d) =>
              e ? Promise.reject(e) : Promise.resolve(d)
            ),
          () =>
            api.setThreadTheme(threadId, { id: themeIdentifier }, (e, d) =>
              e ? Promise.reject(e) : Promise.resolve(d)
            ),
          () =>
            api.setThreadTheme(threadId, { theme_id: themeIdentifier }, (e, d) =>
              e ? Promise.reject(e) : Promise.resolve(d)
            ),
          () =>
            api.setThreadTheme(threadId, { theme: themeIdentifier }, (e, d) =>
              e ? Promise.reject(e) : Promise.resolve(d)
            ),
          () =>
            api.setThreadTheme(threadId, { themeID: themeIdentifier }, (e, d) =>
              e ? Promise.reject(e) : Promise.resolve(d)
            ),
          // pass the full object if available (some APIs expect object payload)
          () =>
            selectedObject
              ? api.setThreadTheme(threadId, selectedObject, (e, d) => (e ? Promise.reject(e) : Promise.resolve(d)))
              : Promise.reject(new Error("no full object candidate"))
        ];

        const errors = [];
        for (let i = 0; i < candidates.length; i++) {
          try {
            // each candidate returns a callback-style API; wrap in Promise.resolve to catch returned promises or results
            const res = await new Promise((resolve, reject) => {
              try {
                // candidates[i] may call api.setThreadTheme with a callback and return undefined; we handle via the callback inside
                candidates[i]().then ? candidates[i]().then(resolve).catch(reject) : resolve();
              } catch (err) {
                reject(err);
              }
            });
            // success
            return { ok: true, shapeIndex: i, result: res };
          } catch (err) {
            // record GraphQL-like errors or other errors
            errors.push({ index: i, error: err });
            // if the error is explicitly critical, we can break early; but usually we try next shape
          }
        }

        // none succeeded
        const aggregate = new Error("All candidate payloads failed to apply theme.");
        aggregate.details = errors;
        throw aggregate;
      };

      // --- Direct apply mode: --id <theme_id> ---
      if (directId) {
        const threadToUse =
          resolveThreadId(targetThread) ||
          resolveThreadId(event.threadID) ||
          resolveThreadId(event.threadId) ||
          (event.chat && resolveThreadId(event.chat.id)) ||
          (event.message && resolveThreadId(event.message.threadID));

        if (!threadToUse) return message.reply("‚ùå Target thread not found or invalid.");

        await message.reply(`üîß Applying theme ID ${directId} to thread ${threadToUse}...`);

        try {
          const attempted = await tryApplyTheme(threadToUse, directId, null);
          return message.reply(
            `‚úÖ Theme (${directId}) applied to thread ${threadToUse}. (payload shape #${attempted.shapeIndex})`
          );
        } catch (err) {
          // if GraphQL-style error object present, serialize key fields to help debugging
          const detailText =
            err && err.details
              ? err.details
                  .map((d) => {
                    const e = d.error || d;
                    const msg = e.message || (e.toString && e.toString()) || JSON.stringify(e);
                    return `shape#${d.index}: ${msg}`;
                  })
                  .join("\n")
              : err && err.message
              ? err.message
              : String(err);
          console.error("aitheme:directApply failed", err);
          return message.reply(
            `‚ùå Failed to apply theme ${directId}.\nReason: ${detailText}\n\nTip: Ensure the theme id is valid, you have permission to change thread theme, and the environment's setThreadTheme expects one of the standard payload shapes.`
          );
        }
      }

      // --- Generate mode: require prompt or url ---
      if (!promptText && !bgUrl) {
        return message.reply(
          `‚ö†Ô∏è Provide a prompt, or supply --url, or use --id. See: ${this.config.guide.en}`
        );
      }

      await message.reply(
        `üé® Creating ${variantCount} AI theme variant${variantCount > 1 ? "s" : ""}...`
      );

      const requestOptionsBase = {
        variantCount,
        numThemes: variantCount,
        n: variantCount,
        count: variantCount,
        v: variantCount
      };
      if (bgUrl) requestOptionsBase.background = bgUrl;

      const runThemeBuilderOnce = (p, opt) =>
        new Promise((resolve, reject) => {
          try {
            if (typeof api.produceMetaTheme === "function")
              return api.produceMetaTheme(p, opt, (e, d) => (e ? reject(e) : resolve(d)));
            if (typeof api.metaTheme === "function")
              return api.metaTheme(p, opt, (e, d) => (e ? reject(e) : resolve(d)));
            return reject(new Error("Theme generator not available."));
          } catch (e) {
            reject(e);
          }
        });

      const finalPrompt = promptText || "image_based_theme";
      let themePackage = null;
      try {
        themePackage = await runThemeBuilderOnce(finalPrompt, requestOptionsBase);
      } catch (e) {
        try {
          themePackage = await runThemeBuilderOnce(finalPrompt, { numThemes: variantCount, background: bgUrl });
        } catch (e2) {
          themePackage = themePackage || null;
        }
      }

      // collect themes ensuring uniqueness (by themeId or id or name)
      const collected = [];
      const seenIds = new Set();
      const pushTheme = (t) => {
        const id = t?.themeId || t?.id || t?.themeID || t?.name || JSON.stringify(t);
        if (!seenIds.has(id)) {
          seenIds.add(id);
          collected.push(t);
        }
      };

      if (themePackage && Array.isArray(themePackage.themes)) {
        themePackage.themes.forEach(pushTheme);
      }

      const attemptsLimit = Math.max(variantCount * 2, 4);
      let attempts = 0;
      while (collected.length < variantCount && attempts < attemptsLimit) {
        attempts++;
        try {
          const extra = await runThemeBuilderOnce(finalPrompt, requestOptionsBase);
          if (extra && Array.isArray(extra.themes)) {
            extra.themes.forEach(pushTheme);
          } else if (extra && extra.theme) {
            pushTheme(extra.theme);
          }
        } catch (e) {
          console.log("aitheme: repeated generation attempt failed", e?.message || e);
          break;
        }
      }

      if (!collected.length) {
        return message.reply("‚ùå No themes returned. Try again with a different prompt or URL.");
      }

      const themes = collected.slice(0, variantCount);

      let responseBody = `‚ú® AI Theme Variants Generated for: "${finalPrompt}"\n\n`;
      const attachments = [];

      for (let i = 0; i < themes.length; i++) {
        const item = themes[i];
        const tId = item.themeId || item.id || item.themeID || `unknown_${i + 1}`;
        const color = item.colors?.fallback || (Array.isArray(item.colors) ? item.colors[0] : "n/a");
        const bg = item.images?.background || item.backgroundImage;

        responseBody += `${i + 1}. ${item.name || "Unnamed"} (ID: ${tId})\n`;
        responseBody += `   ‚Ä¢ Main Color: ${color}\n`;
        responseBody += `   ‚Ä¢ Info: ${item.description || "Generated theme"}\n`;

        if (bg) {
          responseBody += `   ‚Ä¢ Background: available\n`;
          try {
            const imgStream = await global.utils.getStreamFromURL(bg);
            attachments.push(imgStream);
          } catch (e) {
            console.log("aitheme: failed to fetch background", e?.message || e);
          }
        }
        responseBody += `\n`;
      }

      responseBody += `üìå Reply with a number (1-${themes.length}) to apply a theme.`;

      const sent = await message.reply({
        body: responseBody,
        attachment: attachments.length ? attachments : undefined
      });

      const replyState = {
        cmd: this.config.name,
        commandName: this.config.name,
        command: this.config.name,
        name: this.config.name,

        requester: event.senderID,
        themeSet: themes,
        thread: event.threadID,
        messageID: sent.messageID || null,
        messageId: sent.messageId || sent.messageID || null
      };

      if (replyState.messageID) global.GoatBot.onReply.set(replyState.messageID, replyState);
      if (replyState.messageId) global.GoatBot.onReply.set(replyState.messageId, replyState);

      return sent;
    } catch (err) {
      console.error("aitheme:onStart", err);
      return message.reply(`‚ùå Error: ${err?.message || err}`);
    }
  },

  onReply: async function ({ message, Reply, event, args, api }) {
    try {
      if (!Reply) return;

      const replyCmd = Reply.cmd || Reply.commandName || Reply.command || Reply.name;
      if (replyCmd !== this.config.name) return;

      if (event.senderID !== Reply.requester) {
        return message.reply("‚õî Only the requester can select a theme.");
      }

      const rawInput = (args && args[0]) || (event.body || event.text || "");
      const choice = parseInt(String(rawInput).trim(), 10);
      const themeList = Reply.themeSet || [];

      if (!choice || choice < 1 || choice > themeList.length) {
        return message.reply(`‚ö†Ô∏è Choose a number from 1 to ${themeList.length}.`);
      }

      const selected = themeList[choice - 1];
      const themeID = selected.themeId || selected.id || selected.themeID || selected;

      // unsend the preview message if possible; accept both messageID / messageId
      try {
        const mid = Reply.messageID || Reply.messageId || null;
        if (mid && typeof api.unsendMessage === "function") {
          api.unsendMessage(mid);
        }
      } catch (e) {
        console.log("aitheme: unsend failed", e?.message || e);
      }

      // apply theme robustly
      try {
        const threadToUse = Reply.thread || event.threadID || event.threadId;
        const attempted = await (async () => {
          // allow full object as extra candidate
          return await (async () => {
            // try multiple payload shapes
            const result = await (async () => {
              // reuse tryApplyTheme logic from onStart - copy here to avoid refactoring across file scope
              if (typeof api.setThreadTheme !== "function") {
                throw new Error("setThreadTheme API is not available in this environment.");
              }

              const payloadCandidates = [
                (cb) => api.setThreadTheme(threadToUse, themeID, cb),
                (cb) => api.setThreadTheme(threadToUse, { themeId: themeID }, cb),
                (cb) => api.setThreadTheme(threadToUse, { id: themeID }, cb),
                (cb) => api.setThreadTheme(threadToUse, { theme_id: themeID }, cb),
                (cb) => api.setThreadTheme(threadToUse, { theme: themeID }, cb),
                (cb) => api.setThreadTheme(threadToUse, { themeID: themeID }, cb),
                (cb) => (selected ? api.setThreadTheme(threadToUse, selected, cb) : cb(new Error("no selected object")))
              ];

              const errs = [];
              for (let i = 0; i < payloadCandidates.length; i++) {
                try {
                  const res = await new Promise((resolve, reject) => {
                    try {
                      payloadCandidates[i]((err, data) => (err ? reject(err) : resolve(data)));
                    } catch (e) {
                      reject(e);
                    }
                  });
                  return { ok: true, idx: i, res };
                } catch (e) {
                  errs.push({ idx: i, error: e });
                }
              }
              const agg = new Error("All candidate payloads failed in onReply.");
              agg.details = errs;
              throw agg;
            })();
            return result;
          })();
        })();

        return message.reply(
          `‚úÖ Theme Applied: "${selected.name || themeID}"\n‚Ä¢ ID: ${themeID}\n(applied using payload shape #${attempted.idx})`
        );
      } catch (err) {
        const detailText =
          err && err.details
            ? err.details
                .map((d) => {
                  const e = d.error || d;
                  const msg = e.message || (e.toString && e.toString()) || JSON.stringify(e);
                  return `shape#${d.idx}: ${msg}`;
                })
                .join("\n")
            : err && err.message
            ? err.message
            : String(err);
        console.error("aitheme:onReply apply failed", err);
        return message.reply(
          `‚ùå Failed to apply theme ${themeID}.\nReason: ${detailText}\n\nIf this looks like a GraphQL server error: check that the theme ID is correct, your bot session is fully authenticated, and the environment's API expects one of the tried payload shapes.`
        );
      }
    } catch (err) {
      console.error("aitheme:onReply", err);
      return message.reply(`‚ùå Failed to apply theme: ${err?.message || err}`);
    }
  }
};